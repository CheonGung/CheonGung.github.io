---
layout: single
title:  "백준 1074번 - Z"
categories: Baekjoon
tags: [PS, Baekjoon]
---

<hr/>
 문제: <a href="https://www.acmicpc.net/problem/1074" target="_blank">Problem1074 - Z</a>
<hr/>
 풀이과정: (3.1)의 수는 (3.0)의 수와 (0.1)의 수의 합과 같다.

 결국 행의 배열 규칙과 열의 배열 규칙을 알아내고, 구하고자 하는  행과 열에 있는 두 수를 더하면 된다.

 <br>

 우선 행의 숫자는 0 2 8 10 32 34 40 42 이다. 이를 2의 제곱의 합으로 나타내보자.

 0 2^1 2^3 2^1+2^3 2^5 2^5+2^1 2^5+2^3 2^5+2^3+2^1
 
 이렇게 나타내보니 지수에 규칙이 있다. 1 3 1,3 5 1,5 3,5 1,3,5 이런 식이다.

 나는 이러한 규칙이 이진법을 이용해서 나타낼 수 있다고 생각하였다.

 예를 들어 행을 가르치는 변수 r이 10이라면 이진수로는0b1010일 것이다.
 
 0b를 슬라이싱으로 자르고 1010을 문자열 하나씩 리스트에 저장하고 거꾸로 돌리면 ['0','1','0','1']이 될 것이다.

 리스트의 숫자를 하나씩 정수형으로 가져와서 2를곱하고 -1을 해주면 3,7이 될 것이다.

 그 다음에 2^3 + 2^7 = 136으로 (10. 0)의 수를 반환하게 된다.

 <br>

 열의 숫자는 0 1 4 5 16 17 20 21 이다. 이를 2의 제곱의 합으로 나타내보자.

 0 2^0 2^2 2^2+2^0 2^4 2^4+2^0 2^4+2^2 2^4+2^2+2^0

 이번에도 동일하게 지수에 규칙이 있다.

 행의 방법과 같이 리스트의 숫자를 정수형으로 가져온 다음에, 이번엔 2를 곱하고 -2를 해주면 된다.

 <br>

 행의 숫자와 열의 숫자를 구했다면, 두 수를 더하면 원하는 숫자가 나온다.

 <br>

 다만 이러한 방법은 입력한 N을 사용하지 않는다.

 아마도 N을 사용한다면 더 좋은 코드를 만들 수 있을 것이라고 생각한다.
<hr/>
 코드

```python
N, r, c = list(map(int,input().split()))

rlst = []
clst = []
r_value = 0
c_value = 0

rlst = list(bin(r)[2:]) # 0b자르기
rlst.reverse() # 리스트의 숫자의 순서 반전.
count = 0 # 1이 나온 순번을 저장할 변수 선언
for i in rlst:
    count += 1 
    if int(i) == 1: 
        r_value += 2**(count*2-1) # 순번에 2를 곱하고 1을 뺀 숫자로 2를 제곱한다.

clst = list(bin(c)[2:])
clst.reverse()
count = 0
for i in clst:
    count += 1
    if int(i) == 1:
        c_value += 2**(count*2-2) # 순번에 2를 곱하고 2를 뺀 숫자로 2를 제곱한다.

print(r_value + c_value) # 결과값 출력
```